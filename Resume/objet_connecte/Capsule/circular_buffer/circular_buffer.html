<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>circular_buffer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circular_buffer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from typing import Iterable, TypeVar, Generic



T = TypeVar(&#39;T&#39;)
&#34;&#34;&#34;A generic type alias for any type.&#34;&#34;&#34;



class CircularBuffer(Generic[T]):
    &#34;&#34;&#34;A circular buffer is a data structure that uses a single, fixed-size 
    buffer as if it were connected end-to-end.
    
    The buffer is treated as a circular data structure, meaning that the buffer 
    is logically contiguous and wrapped around. This means that the buffer is 
    treated as though the memory is contiguous and circular in nature.
    
    The buffer has a fixed capacity, and when the buffer is full, pushing a new 
    element will overwrite the oldest element.
    
    The buffer is implemented using a list of fixed size, and the buffer is 
    treated as a circular list.
    
    The buffer implement the following :
     - dunder methods:
       - __str__()
       - __repr__()
       - __format__() :
         - size
         - capacity
         - load
         - raw
       - __len__() : 
         - get the number of elements in the buffer
         - this value is fixed after the buffer is fully filled (via push method)
       - __getitem__(index) : 
         - get the element at the given index
         - the index can be negative
         - the index represent the circular index and not the physical index
       - __setitem__(index, value) : set the element at the given index
         - set the element at the given index
         - the index can be negative
         - the index represent the circular index and not the physical index
       - __iter__() : get an iterator over the elements in the buffer
         - return a facade iterator over the buffer
         - the iterator is a class defined inside the CircularBuffer class
         - the iterator stop when all elements are visited once
     - properties:
         - capacity : get the capacity of the buffer
         - size : get the number of elements in the buffer
         - is_empty : check if the buffer is empty
         - is_full : check if the buffer is full
     - methods:
         - push(value) : push a new element to the buffer
         - pop(value) : remove the last element from the buffer
         - clear() : remove all elements from the buffer
    &#34;&#34;&#34;
    
    # to do : add init_values # def __init__(self, *, capacity : int, init_values : None | T | Iterable[T] = None) -&gt; None:
    def __init__(self, capacity : int) -&gt; None:
        &#34;&#34;&#34;Create a new circular buffer with the given capacity.
        
        Args:
            capacity (int): the capacity of the buffer, must be strictly positive
            
        Raises:
            TypeError: if the capacity is not an int
            ValueError: if the capacity is not strictly positive
        
        Example as doctest :
        &gt;&gt;&gt; data = CircularBuffer(capacity = 5)
        &gt;&gt;&gt; len(data)
        0
        &gt;&gt;&gt; data.push(10)
        &gt;&gt;&gt; data.push(9)
        &gt;&gt;&gt; len(data)
        2
        &gt;&gt;&gt; data[0], data[1]
        (10, 9)
        &gt;&gt;&gt; data[-1]
        9
        &gt;&gt;&gt; data.clear()
        &gt;&gt;&gt; len(data)
        0
        &gt;&gt;&gt; data.push(10)
        &gt;&gt;&gt; data.push(9)
        &gt;&gt;&gt; data.push(8)
        &gt;&gt;&gt; data.push(7)
        &gt;&gt;&gt; for value in data:
        ...    print(value, end=&#39;_|_&#39;)
        10_|_9_|_8_|_7_|_
        &#34;&#34;&#34;
        if not isinstance(capacity, int):
            raise TypeError(&#39;capacity must be an int&#39;)
        if capacity &lt;= 0:
            raise ValueError(&#39;capacity must be strictly positive&#39;)
                
        self._capacity : int = capacity
        self._data : list[CircularBuffer.T | None] = [None] * self._capacity # pre-allocate the memory!
        self._first : int = 0
        self._size : int = 0
        
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Get the string representation of the buffer.&#34;&#34;&#34;
        if self.size &lt; 4:
            txt = &#39;, &#39;.join(str(value) for value in self)
        else:
            txt = str(self[0])
            for i in range(1, 3):
                txt += f&#39;, {self[i]}&#39;
            txt += &#39;, ...&#39;
        return f&#39;&lt;{txt}&gt;&#39;
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Get the string representation of the buffer.&#34;&#34;&#34;
        return f&#39;{self.__class__.__name__}(capacity = {self._capacity}) at {id(self):#x}&#39;
    
    def __format__(self, format_spec : str) -&gt; str:
        &#34;&#34;&#34;Get the formatted representation of the buffer.&#34;&#34;&#34;
        match format_spec:
            case &#39;size&#39;:
                return str(self._size)
            case &#39;capacity&#39;:
                return str(self._capacity)
            case &#39;load&#39;:
                return f&#39;{self._size} / {self._capacity} ({self._size / self._capacity * 100.0:.1f} %)&#39;
            case &#39;full&#39;:
                return f&#34;&lt;{&#39;, &#39;.join(str(value) for value in self)}&gt;&#34;
            case &#39;raw&#39;:
                return str(self._data)
            case _:
                return str(self)
        
    def _index_of(self, index: int) -&gt; int:
        &#34;&#34;&#34;Get the physical index of the given logical circular index.&#34;&#34;&#34;
        if index &lt; 0:
            index = self._size + index
        if not 0 &lt;= index &lt; self._size:
            raise IndexError(f&#39;index out of range, {index} was given for a size of {self._size}&#39;)
        return (self._first + index) % self._capacity
        
    def __getitem__(self, index : int) -&gt; T:
        &#34;&#34;&#34;Get the element at the given index.&#34;&#34;&#34;
        return self._data[self._index_of(index)]

    def __setitem__(self, index : int, value : T) -&gt; None:
        &#34;&#34;&#34;Set the element at the given index.&#34;&#34;&#34;
        self._data[self._index_of(index)] = value

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Get the number of elements in the buffer.&#34;&#34;&#34;
        return self._size
    
    def __contains__(self, value : T) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer contains the given value.&#34;&#34;&#34;
        # return value in self._data[self._first:self._first + self._size] or value in self._data[:self._capacity - (self._first + self._size)]
        if self.is_empty:
            return False
        elif self.is_full:
            return value in self._data
        elif self._first + self._size &lt;= self._capacity:
            return value in self._data[self._first:self._first + self._size]
        else:
            return value in self._data[self._first:] or value in self._data[:self._capacity - self._first]
    
    class _Iterator:
        &#34;&#34;&#34;A facade iterator over the elements in the buffer.&#34;&#34;&#34;
        def __init__(self, circular_buffer : CircularBuffer) -&gt; None:
            &#34;&#34;&#34;Create a new iterator over the given circular buffer.&#34;&#34;&#34;
            self._buffer = circular_buffer
            self._index = 0
            
        def __next__(self) -&gt; T:
            &#34;&#34;&#34;&#34;Get the next element in the buffer.&#34;&#34;&#34;
            if self._index &gt;= self._buffer._size:
                raise StopIteration
            value = self._buffer[self._index]
            self._index += 1
            return value
    
    def __iter__(self) -&gt; CircularBuffer._Iterator:
        &#34;&#34;&#34;Get an iterator over the elements in the buffer.&#34;&#34;&#34;
        return CircularBuffer._Iterator(self)
    
    @property
    def capacity(self) -&gt; int:
        &#34;&#34;&#34;Get the capacity of the buffer.&#34;&#34;&#34;
        return self._capacity
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Get the number of elements in the buffer.&#34;&#34;&#34;
        return self._size
    
    @property
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer is empty.&#34;&#34;&#34;
        return self._size == 0
    
    @property
    def is_full(self) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer is full.&#34;&#34;&#34;
        return self._size == self._capacity
    
    def push(self, value : T) -&gt; None:
        &#34;&#34;&#34;push a new element to the buffer.
        
        If the buffer is full, the oldest element will be overwritten.
        
        Args:
            value (T): the value to push to the buffer
        &#34;&#34;&#34;
        index = (self._first + self._size) % self._capacity
        self._data[index] = value
        if self.is_full:
            self._first = (self._first + 1) % self._capacity
        else:
            self._size += 1
        
    def pop(self) -&gt; None:
        &#34;&#34;&#34;Remove the last element from the buffer.
        
        If the buffer is empty, an IndexError will be raised.
        
        Raises:
            IndexError: if the buffer is empty
        &#34;&#34;&#34;
        if self.is_empty:
            raise IndexError(&#39;pop from an empty buffer&#39;)
        self._first = (self._first + 1) % self._capacity
        self._size -= 1
        
    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all elements from the buffer.
        
        Clear the content without changing the capacity.
        &#34;&#34;&#34;
        self._first = 0
        self._size = 0


if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="circular_buffer.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"><p>A generic type alias for any type.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="circular_buffer.CircularBuffer"><code class="flex name class">
<span>class <span class="ident">CircularBuffer</span></span>
<span>(</span><span>capacity: int)</span>
</code></dt>
<dd>
<div class="desc"><p>A circular buffer is a data structure that uses a single, fixed-size
buffer as if it were connected end-to-end.</p>
<p>The buffer is treated as a circular data structure, meaning that the buffer
is logically contiguous and wrapped around. This means that the buffer is
treated as though the memory is contiguous and circular in nature.</p>
<p>The buffer has a fixed capacity, and when the buffer is full, pushing a new
element will overwrite the oldest element.</p>
<p>The buffer is implemented using a list of fixed size, and the buffer is
treated as a circular list.</p>
<p>The buffer implement the following :
- dunder methods:
- <strong>str</strong>()
- <strong>repr</strong>()
- <strong>format</strong>() :
- size
- capacity
- load
- raw
- <strong>len</strong>() :
- get the number of elements in the buffer
- this value is fixed after the buffer is fully filled (via push method)
- <strong>getitem</strong>(index) :
- get the element at the given index
- the index can be negative
- the index represent the circular index and not the physical index
- <strong>setitem</strong>(index, value) : set the element at the given index
- set the element at the given index
- the index can be negative
- the index represent the circular index and not the physical index
- <strong>iter</strong>() : get an iterator over the elements in the buffer
- return a facade iterator over the buffer
- the iterator is a class defined inside the CircularBuffer class
- the iterator stop when all elements are visited once
- properties:
- capacity : get the capacity of the buffer
- size : get the number of elements in the buffer
- is_empty : check if the buffer is empty
- is_full : check if the buffer is full
- methods:
- push(value) : push a new element to the buffer
- pop(value) : remove the last element from the buffer
- clear() : remove all elements from the buffer</p>
<p>Create a new circular buffer with the given capacity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code></dt>
<dd>the capacity of the buffer, must be strictly positive</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if the capacity is not an int</dd>
<dt><code>ValueError</code></dt>
<dd>if the capacity is not strictly positive</dd>
</dl>
<p>Example as doctest :</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; data = CircularBuffer(capacity = 5)
&gt;&gt;&gt; len(data)
0
&gt;&gt;&gt; data.push(10)
&gt;&gt;&gt; data.push(9)
&gt;&gt;&gt; len(data)
2
&gt;&gt;&gt; data[0], data[1]
(10, 9)
&gt;&gt;&gt; data[-1]
9
&gt;&gt;&gt; data.clear()
&gt;&gt;&gt; len(data)
0
&gt;&gt;&gt; data.push(10)
&gt;&gt;&gt; data.push(9)
&gt;&gt;&gt; data.push(8)
&gt;&gt;&gt; data.push(7)
&gt;&gt;&gt; for value in data:
...    print(value, end='_|_')
10_|_9_|_8_|_7_|_
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CircularBuffer(Generic[T]):
    &#34;&#34;&#34;A circular buffer is a data structure that uses a single, fixed-size 
    buffer as if it were connected end-to-end.
    
    The buffer is treated as a circular data structure, meaning that the buffer 
    is logically contiguous and wrapped around. This means that the buffer is 
    treated as though the memory is contiguous and circular in nature.
    
    The buffer has a fixed capacity, and when the buffer is full, pushing a new 
    element will overwrite the oldest element.
    
    The buffer is implemented using a list of fixed size, and the buffer is 
    treated as a circular list.
    
    The buffer implement the following :
     - dunder methods:
       - __str__()
       - __repr__()
       - __format__() :
         - size
         - capacity
         - load
         - raw
       - __len__() : 
         - get the number of elements in the buffer
         - this value is fixed after the buffer is fully filled (via push method)
       - __getitem__(index) : 
         - get the element at the given index
         - the index can be negative
         - the index represent the circular index and not the physical index
       - __setitem__(index, value) : set the element at the given index
         - set the element at the given index
         - the index can be negative
         - the index represent the circular index and not the physical index
       - __iter__() : get an iterator over the elements in the buffer
         - return a facade iterator over the buffer
         - the iterator is a class defined inside the CircularBuffer class
         - the iterator stop when all elements are visited once
     - properties:
         - capacity : get the capacity of the buffer
         - size : get the number of elements in the buffer
         - is_empty : check if the buffer is empty
         - is_full : check if the buffer is full
     - methods:
         - push(value) : push a new element to the buffer
         - pop(value) : remove the last element from the buffer
         - clear() : remove all elements from the buffer
    &#34;&#34;&#34;
    
    # to do : add init_values # def __init__(self, *, capacity : int, init_values : None | T | Iterable[T] = None) -&gt; None:
    def __init__(self, capacity : int) -&gt; None:
        &#34;&#34;&#34;Create a new circular buffer with the given capacity.
        
        Args:
            capacity (int): the capacity of the buffer, must be strictly positive
            
        Raises:
            TypeError: if the capacity is not an int
            ValueError: if the capacity is not strictly positive
        
        Example as doctest :
        &gt;&gt;&gt; data = CircularBuffer(capacity = 5)
        &gt;&gt;&gt; len(data)
        0
        &gt;&gt;&gt; data.push(10)
        &gt;&gt;&gt; data.push(9)
        &gt;&gt;&gt; len(data)
        2
        &gt;&gt;&gt; data[0], data[1]
        (10, 9)
        &gt;&gt;&gt; data[-1]
        9
        &gt;&gt;&gt; data.clear()
        &gt;&gt;&gt; len(data)
        0
        &gt;&gt;&gt; data.push(10)
        &gt;&gt;&gt; data.push(9)
        &gt;&gt;&gt; data.push(8)
        &gt;&gt;&gt; data.push(7)
        &gt;&gt;&gt; for value in data:
        ...    print(value, end=&#39;_|_&#39;)
        10_|_9_|_8_|_7_|_
        &#34;&#34;&#34;
        if not isinstance(capacity, int):
            raise TypeError(&#39;capacity must be an int&#39;)
        if capacity &lt;= 0:
            raise ValueError(&#39;capacity must be strictly positive&#39;)
                
        self._capacity : int = capacity
        self._data : list[CircularBuffer.T | None] = [None] * self._capacity # pre-allocate the memory!
        self._first : int = 0
        self._size : int = 0
        
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Get the string representation of the buffer.&#34;&#34;&#34;
        if self.size &lt; 4:
            txt = &#39;, &#39;.join(str(value) for value in self)
        else:
            txt = str(self[0])
            for i in range(1, 3):
                txt += f&#39;, {self[i]}&#39;
            txt += &#39;, ...&#39;
        return f&#39;&lt;{txt}&gt;&#39;
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Get the string representation of the buffer.&#34;&#34;&#34;
        return f&#39;{self.__class__.__name__}(capacity = {self._capacity}) at {id(self):#x}&#39;
    
    def __format__(self, format_spec : str) -&gt; str:
        &#34;&#34;&#34;Get the formatted representation of the buffer.&#34;&#34;&#34;
        match format_spec:
            case &#39;size&#39;:
                return str(self._size)
            case &#39;capacity&#39;:
                return str(self._capacity)
            case &#39;load&#39;:
                return f&#39;{self._size} / {self._capacity} ({self._size / self._capacity * 100.0:.1f} %)&#39;
            case &#39;full&#39;:
                return f&#34;&lt;{&#39;, &#39;.join(str(value) for value in self)}&gt;&#34;
            case &#39;raw&#39;:
                return str(self._data)
            case _:
                return str(self)
        
    def _index_of(self, index: int) -&gt; int:
        &#34;&#34;&#34;Get the physical index of the given logical circular index.&#34;&#34;&#34;
        if index &lt; 0:
            index = self._size + index
        if not 0 &lt;= index &lt; self._size:
            raise IndexError(f&#39;index out of range, {index} was given for a size of {self._size}&#39;)
        return (self._first + index) % self._capacity
        
    def __getitem__(self, index : int) -&gt; T:
        &#34;&#34;&#34;Get the element at the given index.&#34;&#34;&#34;
        return self._data[self._index_of(index)]

    def __setitem__(self, index : int, value : T) -&gt; None:
        &#34;&#34;&#34;Set the element at the given index.&#34;&#34;&#34;
        self._data[self._index_of(index)] = value

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Get the number of elements in the buffer.&#34;&#34;&#34;
        return self._size
    
    def __contains__(self, value : T) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer contains the given value.&#34;&#34;&#34;
        # return value in self._data[self._first:self._first + self._size] or value in self._data[:self._capacity - (self._first + self._size)]
        if self.is_empty:
            return False
        elif self.is_full:
            return value in self._data
        elif self._first + self._size &lt;= self._capacity:
            return value in self._data[self._first:self._first + self._size]
        else:
            return value in self._data[self._first:] or value in self._data[:self._capacity - self._first]
    
    class _Iterator:
        &#34;&#34;&#34;A facade iterator over the elements in the buffer.&#34;&#34;&#34;
        def __init__(self, circular_buffer : CircularBuffer) -&gt; None:
            &#34;&#34;&#34;Create a new iterator over the given circular buffer.&#34;&#34;&#34;
            self._buffer = circular_buffer
            self._index = 0
            
        def __next__(self) -&gt; T:
            &#34;&#34;&#34;&#34;Get the next element in the buffer.&#34;&#34;&#34;
            if self._index &gt;= self._buffer._size:
                raise StopIteration
            value = self._buffer[self._index]
            self._index += 1
            return value
    
    def __iter__(self) -&gt; CircularBuffer._Iterator:
        &#34;&#34;&#34;Get an iterator over the elements in the buffer.&#34;&#34;&#34;
        return CircularBuffer._Iterator(self)
    
    @property
    def capacity(self) -&gt; int:
        &#34;&#34;&#34;Get the capacity of the buffer.&#34;&#34;&#34;
        return self._capacity
    
    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;Get the number of elements in the buffer.&#34;&#34;&#34;
        return self._size
    
    @property
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer is empty.&#34;&#34;&#34;
        return self._size == 0
    
    @property
    def is_full(self) -&gt; bool:
        &#34;&#34;&#34;Check if the buffer is full.&#34;&#34;&#34;
        return self._size == self._capacity
    
    def push(self, value : T) -&gt; None:
        &#34;&#34;&#34;push a new element to the buffer.
        
        If the buffer is full, the oldest element will be overwritten.
        
        Args:
            value (T): the value to push to the buffer
        &#34;&#34;&#34;
        index = (self._first + self._size) % self._capacity
        self._data[index] = value
        if self.is_full:
            self._first = (self._first + 1) % self._capacity
        else:
            self._size += 1
        
    def pop(self) -&gt; None:
        &#34;&#34;&#34;Remove the last element from the buffer.
        
        If the buffer is empty, an IndexError will be raised.
        
        Raises:
            IndexError: if the buffer is empty
        &#34;&#34;&#34;
        if self.is_empty:
            raise IndexError(&#39;pop from an empty buffer&#39;)
        self._first = (self._first + 1) % self._capacity
        self._size -= 1
        
    def clear(self) -&gt; None:
        &#34;&#34;&#34;Remove all elements from the buffer.
        
        Clear the content without changing the capacity.
        &#34;&#34;&#34;
        self._first = 0
        self._size = 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="circular_buffer.CircularBuffer.capacity"><code class="name">var <span class="ident">capacity</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the capacity of the buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def capacity(self) -&gt; int:
    &#34;&#34;&#34;Get the capacity of the buffer.&#34;&#34;&#34;
    return self._capacity</code></pre>
</details>
</dd>
<dt id="circular_buffer.CircularBuffer.is_empty"><code class="name">var <span class="ident">is_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the buffer is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;Check if the buffer is empty.&#34;&#34;&#34;
    return self._size == 0</code></pre>
</details>
</dd>
<dt id="circular_buffer.CircularBuffer.is_full"><code class="name">var <span class="ident">is_full</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the buffer is full.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_full(self) -&gt; bool:
    &#34;&#34;&#34;Check if the buffer is full.&#34;&#34;&#34;
    return self._size == self._capacity</code></pre>
</details>
</dd>
<dt id="circular_buffer.CircularBuffer.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the number of elements in the buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;Get the number of elements in the buffer.&#34;&#34;&#34;
    return self._size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="circular_buffer.CircularBuffer.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all elements from the buffer.</p>
<p>Clear the content without changing the capacity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self) -&gt; None:
    &#34;&#34;&#34;Remove all elements from the buffer.
    
    Clear the content without changing the capacity.
    &#34;&#34;&#34;
    self._first = 0
    self._size = 0</code></pre>
</details>
</dd>
<dt id="circular_buffer.CircularBuffer.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the last element from the buffer.</p>
<p>If the buffer is empty, an IndexError will be raised.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>if the buffer is empty</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; None:
    &#34;&#34;&#34;Remove the last element from the buffer.
    
    If the buffer is empty, an IndexError will be raised.
    
    Raises:
        IndexError: if the buffer is empty
    &#34;&#34;&#34;
    if self.is_empty:
        raise IndexError(&#39;pop from an empty buffer&#39;)
    self._first = (self._first + 1) % self._capacity
    self._size -= 1</code></pre>
</details>
</dd>
<dt id="circular_buffer.CircularBuffer.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, value: <a title="circular_buffer.T" href="#circular_buffer.T">T</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>push a new element to the buffer.</p>
<p>If the buffer is full, the oldest element will be overwritten.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="circular_buffer.T" href="#circular_buffer.T">T</a></code></dt>
<dd>the value to push to the buffer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, value : T) -&gt; None:
    &#34;&#34;&#34;push a new element to the buffer.
    
    If the buffer is full, the oldest element will be overwritten.
    
    Args:
        value (T): the value to push to the buffer
    &#34;&#34;&#34;
    index = (self._first + self._size) % self._capacity
    self._data[index] = value
    if self.is_full:
        self._first = (self._first + 1) % self._capacity
    else:
        self._size += 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="circular_buffer.T" href="#circular_buffer.T">T</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="circular_buffer.CircularBuffer" href="#circular_buffer.CircularBuffer">CircularBuffer</a></code></h4>
<ul class="two-column">
<li><code><a title="circular_buffer.CircularBuffer.capacity" href="#circular_buffer.CircularBuffer.capacity">capacity</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.clear" href="#circular_buffer.CircularBuffer.clear">clear</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.is_empty" href="#circular_buffer.CircularBuffer.is_empty">is_empty</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.is_full" href="#circular_buffer.CircularBuffer.is_full">is_full</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.pop" href="#circular_buffer.CircularBuffer.pop">pop</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.push" href="#circular_buffer.CircularBuffer.push">push</a></code></li>
<li><code><a title="circular_buffer.CircularBuffer.size" href="#circular_buffer.CircularBuffer.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>